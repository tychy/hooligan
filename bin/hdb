#!/bin/bash

# set -e -> エラーがでたらそこでストップする
# set -u -> 未定義変数をエラーにする
# set -o pipefail -> |の前がfailしたらそこでストップする
set -euo pipefail

clean() {
    for fn in $(find . -name '*.s'); do
        rm $fn
    done
    for fn in $(find . -name 'a.out'); do
        rm $fn
    done
}

compile() {
    ./bin/hcc "$@"
}

assembly() {
    find *.s | xargs cc -static
}

src() {
    make
    compile ${@:1}
    for fn in $(find . -name '*.s'); do
        printf "\n$(basename $fn)\n"
        cat $fn
    done
    clean
}

exec() {
    make
    compile ${@:1}
    for fn in $(find . -name '*.s'); do
        printf "\n$(basename $fn)\n"
        cat $fn
    done
    assembly
    set +e
    ./a.out
    echo "結果: $?"
    clean
    set -e
}

debug() {
    make
    compile ${@:1}
    for fn in $(find . -name '*.s'); do
        printf "\n$(basename $fn)\n"
        cat $fn
    done
    find *.s | xargs cc -static -g -O0
    gdb a.out
    clean
}

asm() {
    cc -static -c "$2" -o a.o
    objdump -d -M Intel a.o
    rm a.o tmp.c
}

runtestold() {
    set +e
    for fn in testold/question/*; do
        i=$(basename $fn)
        qfile=testold/question/$i
        afile=testold/answer/$i
        expected="$(cat $afile)"

        compile $qfile
        find *.s | xargs cc # シンプルなテストなのでstaticをつけなくてもよい
        printf $qfile
        ./a.out
        actual="$?"
        if [ "$actual" = "$expected" ]; then
            printf "...passed\n"
        else
            printf "...failed\n"
            exit 1
        fi
    done
    set -e
    clean
}

runtest() {
    for dn in $(find tests/* -type d); do
        printf $dn
        cfiles=$(find $dn/*.c)
        compile $cfiles
        assembly
        expectedout=$(cat $dn/out)
        stdout=$(./a.out)
        if [ "$stdout" == "$expectedout" ]; then
            echo ...passed
        else
            echo ...failed
            exit 1
        fi
        clean
    done
}

runtest2() {
    for dn in $(find tests/* -type d); do
        printf $dn
        cfiles=$(find $dn/*.c)
        ./bin/hcc_2nd $cfiles
        assembly
        expectedout=$(cat $dn/out)
        stdout=$(./a.out)
        if [ "$stdout" == "$expectedout" ]; then
            echo ...passed
        else
            echo ...failed
            exit 1
        fi
        clean
    done
}

gentest() {
    mkdir tests/$1
    touch tests/$1/main.c
    touch tests/$1/out
}

unittest() {
    gcc unittest/utiltest.c
    expectedout=$(cat unittest/utiltest.txt)
    stdout=$(./a.out)
    if [ "$stdout" == "$expectedout" ]; then
        printf ...passed
    else
        printf ...failed
        exit 1
    fi
    printf "\n"
    clean
}

unittest_hooligan() {
    make
    compile unittest/utiltest.c
    assembly
    expectedout=$(cat unittest/utiltest.txt)
    stdout=$(./a.out)
    if [ "$stdout" == "$expectedout" ]; then
        printf ...passed
    else
        printf ...failed
        exit 1
    fi
    printf "\n"
    clean
}

selfhost() {
    make
    compile generator.c main.c parser.c preprocessor.c read_token.c scope.c tokenizer.c type.c util.c variable.c
    find *.s | xargs cc -static -o bin/hcc_2nd
    clean
}

VALUE_D=true
while getopts d: OPT; do
    case $OPT in
    'd') VALUE_D=$OPTARG ;;
    esac
done

shift $((OPTIND - 1))
if "${VALUE_D}"; then
    if [ $1 != "unittest" ] && [ $1 != "gentest" ]; then
        docker-compose run hooligan ./bin/hdb -d false ${@:1}
        exit
    fi
fi

if [ $1 = "clean" ]; then
    clean
elif [ $1 = "src" ]; then
    src ${@:2}
elif [ $1 = "exec" ]; then
    exec ${@:2}
elif [ $1 = "debug" ]; then
    debug ${@:2}
elif [ $1 = "asm" ]; then
    asm $2
elif [ $1 = "test" ]; then
    make
    if [ $# = 2 ] && [ $2 = "all" ]; then
        runtest
        runtestold
        unittest
    else
        runtest
    fi
elif [ $1 = "runtest2" ]; then
    runtest2
elif [ $1 = "gentest" ]; then
    gentest $2
elif [ $1 = "unittest" ]; then
    unittest
elif [ $1 = "unittesthoo" ]; then
    unittest_hooligan
elif [ $1 = "selfhost" ]; then
    selfhost
else
    echo "存在しないサブコマンドです"
    exit 1
fi
