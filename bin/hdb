#!/bin/bash

# set -e -> エラーがでたらそこでストップする
# set -u -> 未定義変数をエラーにする
# set -o pipefail -> |の前がfailしたらそこでストップする
set -euo pipefail

clean() {
    for fn in $(find . -name '*.s'); do
        rm $fn
    done
    for fn in $(find . -name 'a.out'); do
        rm $fn
    done
    rm core.*
}

compile() {
    ./bin/$COMPILER_FILE_NAME "$@"
}

assembly() {
    find *.s | xargs cc -static -g -O0
}

src() {
    make
    compile ${@:1}
    for fn in $(find . -name '*.s'); do
        printf "\n$(basename $fn)\n"
        cat $fn
    done
    clean
}

exec() {
    make
    compile ${@:1}
    for fn in $(find . -name '*.s'); do
        printf "\n$(basename $fn)\n"
        cat $fn
    done
    assembly
    set +e
    ./a.out
    echo "結果: $?"
    clean
    set -e
}

debug() {
    make
    compile ${@:1}
    for fn in $(find . -name '*.s'); do
        printf "\n$(basename $fn)\n"
        cat $fn
    done
    find *.s | xargs cc -static -g -O0
    gdb a.out
    clean
}

asm() {
    cc -static -c "$2" -o a.o
    objdump -d -M Intel a.o
    rm a.o tmp.c
}

runtestold() {
    set +e
    for fn in testold/question/*; do
        i=$(basename $fn)
        qfile=testold/question/$i
        afile=testold/answer/$i
        expected="$(cat $afile)"

        compile $qfile
        find *.s | xargs cc # シンプルなテストなのでstaticをつけなくてもよい
        printf $qfile
        ./a.out
        actual="$?"
        if [ "$actual" = "$expected" ]; then
            printf "...passed\n"
        else
            printf "...failed\n"
            exit 1
        fi
    done
    set -e
    clean
}

runtest() {
    for dn in $(find tests/* -type d); do
        printf $dn
        cfiles=$(find $dn/*.c)
        compile $cfiles
        assembly
        expectedout=$(cat $dn/out)
        stdout=$(./a.out)
        if [ "$stdout" == "$expectedout" ]; then
            echo ...passed
        else
            echo ...failed
            exit 1
        fi
        clean
    done
}

runtest2() {
    for dn in $(find tests/* -type d); do
        printf $dn
        cfiles=$(find $dn/*.c)
        ./bin/hcc_2nd $cfiles
        assembly
        expectedout=$(cat $dn/out)
        stdout=$(./a.out)
        if [ "$stdout" == "$expectedout" ]; then
            echo ...passed
        else
            echo ...failed
            exit 1
        fi
        clean
    done
}

gentest() {
    mkdir tests/$1
    touch tests/$1/main.c
    touch tests/$1/out
}

unittest_raw() {
    for dn in $(find unittest/* -maxdepth 0 -type d); do
        printf $dn
        gcc $dn/test.c
        expectedout=$(cat $dn/stdout.txt)
        ./a.out
        printf "\n"
    done
}

unittest() {
    for dn in $(find unittest/* -maxdepth 0 -type d); do
        printf $dn
        gcc $dn/test.c
        expectedout=$(cat $dn/stdout.txt)
        stdout=$(./a.out)
        if [[ "$stdout" == "$expectedout" ]]; then
            printf ...passed
        else
            printf ...failed
            printf "\n"
            exit 1
        fi
        printf "\n"
    done
}

unittest_hooligan() {
    for dn in $(find unittest/* -maxdepth 0 -type d); do
        printf $dn
        compile $dn/test.c
        ls -d *.s | assembly
        expectedout=$(cat $dn/stdout.txt)
        stdout=$(./a.out)
        if [[ "$stdout" == "$expectedout" ]]; then
            printf ...passed
        else
            printf ...failed
            printf "\n"
            exit 1
        fi
        printf "\n"
    done
    clean
}

selfhost() {
    make
    compile generator.c main.c parser.c preprocessor.c read_token.c scope.c tokenizer.c type.c util.c variable.c tokenizer2.c
    find *.s | xargs cc -static -o bin/hcc_2nd
    clean
}

selfhost2() {
    make
    ls -d oldsrc/*.c | xargs ./bin/hcc
    find *.s | xargs cc -static -o bin/hcc_2nd
    clean
}

COMPILER_FILE_NAME=hcc
VALUE_D=true
while getopts c:d: OPT; do
    case $OPT in
    c) COMPILER_FILE_NAME="$OPTARG" ;;
    d) VALUE_D=$OPTARG ;;
    esac
done

shift $((OPTIND - 1))
if "${VALUE_D}"; then
    if [ $1 != "unittest" ] && [ $1 != "gentest" ]; then
        docker-compose run hooligan ./bin/hdb -d false -c $COMPILER_FILE_NAME ${@:1}
        exit
    fi
fi

if [ $1 = "clean" ]; then
    clean
elif [ $1 = "src" ]; then
    src ${@:2}
elif [ $1 = "exec" ]; then
    exec ${@:2}
elif [ $1 = "debug" ]; then
    debug ${@:2}
elif [ $1 = "asm" ]; then
    asm $2
elif [ $1 = "test" ]; then
    make
    if [ $# = 2 ] && [ $2 = "all" ]; then
        runtest
        runtestold
        unittest
    else
        runtest
    fi
elif [ $1 = "runtest2" ]; then
    runtest2
elif [ $1 = "gentest" ]; then
    gentest $2
elif [ $1 = "unittest" ]; then
    unittest
elif [ $1 = "unittest_raw" ]; then
    unittest_raw
elif [ $1 = "unittest_hoo" ]; then
    unittest_hooligan
elif [ $1 = "selfhost" ]; then
    selfhost
elif [ $1 = "selfhost2" ]; then
    selfhost2
else
    echo "存在しないサブコマンドです"
    exit 1
fi
